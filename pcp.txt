
# acls may be used to override the users umask when creating a file with many programs,
# but strangely not when a file is created using 'cp'.  With acls 'cp' acts more like 'cp
# -p', the permission preserving version of cp.  So here is a script that may be used to
# copy files into a project while respecting the project directory's acls.

# todo: add more options

Concepts and Terminology

  The 'p' in 'pcp' stands for 'project'.  The command is 'project copy'.

  Trees are made of <em>nodes</em> and directional <em>arcs</em>. A directional arc is
  said to start at a <em>parent</em> node and then lead to a <em>child</em> node.  There
  is exactly one node in the tree which has no parent.  It is called the <em>root</em>
  node.  All other nodes have exactly one parent. This property is what causes such a
  graph to be a tree.  Nodes that have no children are said to be <em>leaf</em> nodes.  A
  node is either a parent or a leaf.  Each parent, except for the root, is also a child.
  Each parent may also be said to be the root of a <em>subtree</em>.

  Conventionally we also call the root node the <em>top of the tree</em> and we say that
  children are <em>under</em> their parents, thus to traverse the tree to a given node, we
  start at the top and traverse downward.

  A path through a tree is a sequence of arcs starting at the root node and leading to a
  destination node. Starting at the root and then following each arc one by one causes us
  to descend to ever lower levels of the tree until finally arriving at the destination
  node.  Each node in the tree is the destination of exactly one path.

  In filesystem trees parent nodes are called 'folders' or 'directories', while leaf
  nodes are called 'files'.  Files may be of various types, some file are deemed to be
  <em>special</em>.

  For a filesystem tree the arcs are named.  Arc names do not need to be unique within
  the whole of the tree, but the arcs stemming from any parent node to its immediate
  children must have unique names within that context.  Thus in a filesystem tree we use
  a sequence of arc names to identify each node.

  In our filesystem the nodes themselves do not have names, or at least their names are
  not exposed to users. Each node is identified solely by the sequences of arc names that
  lead to it.  Such a sequence of names is said to be a <em>filesystem path</em>.  A file
  system path differs from a tree path in that a filesystem path is a sequence of names,
  while a tree path is a sequence of arcs.

  When using a filesystem we conventionally have the concept of the "present working
  directory", which is a default filesystem path.  A given filesystem path may then be
  <em>relative</em>, which means that it is a suffix to the present working directory
  path, or it may be <em>absolute</em>, which means it leads from the root of the file
  system tree.

  Specifically in the nomenclature used herein, we will call the last name to appear in a
  a sequence of arc names, the <em>child_name</em>.  We then call the longest proper
  prefix of an arc name sequence, the <em>parent_path</em>.  A parent_path uniquely
  identifies a node in the filesystem tree.  The combination of a parent_path and a
  child_name uniquely identifies a child node.  However, the child_name by itself can
  be ambiguous.

  From this point forward in this document and in the code comments, when I write
  <em>path</em> without further qualification, I am referring to a filesystem path.

  Symbolic links may be added to a filesystem tree.  A symbolic link is a special file
  where the contents of that files gives the path to another filesystem object.  This
  contained path is known as the <em>destination</em> of the link. The destination of a
  link may be another link. Typically one expects that after following the one or more
  links in a link chain, that one will arrive at a non-link filesystem object.  

  Python's os.path.isdir and os.path.isfile will tell us about the destination a link
  chain, rather than about the link objects themselves.

  pcp is a program for copying files or subtrees.  It is given one or more source paths,
  and one target path.  A source path may lead to a file or a directory.  If it is a
  directory, then that directory is taken to be the parent of a subtree.  A target path
  may lead to a directory, or it might be an imagined path that does not exist
  yet.  If it does not exist, a directory will be created at that path.  The sources
  are then copied into that directory.

Source Limitations:

  1. there must be at least one source path
  2. source paths must exist in the filesystem before the copy starts

Target limitations

  1. there must be at least one target, it appears last on the argument list
  2. if the target path is imagined, we create it

Issue of circular copies

  Initially pcp was a simple script that piped through tar.  However there was an obnoxious
  hazard.  It was possible to put the target in the source subtree and create an infinite
  copy.  This could fill up the disk and lockup the system; thus make recovery difficult.
  Detecting such a hazard requires traversing each source tree while looking
  for a real pathname match with the target.  In addition, fundamentally, there is nothing
  wrong with copying a source tree into itself. It just becomes a recursive structure, we
  just need to control the recursion depth.
  
  We can deal with the recursion by first copying the sources to a temporary directory,
  and then after they have all been gathered, to move the resulting directory to the
  target.  However, we can not do a move into a directory with acls and expect the newly
  moved files to respect the acls. An option would be to scan through the tree setting the
  permissions correctly before moving it to the destination.  We would have to also scan
  the target to find what those permissions should be.

  We could copy twice, once into /tmp, then into the target, then delete the /tmp version.
  This would require having enough empty disk space to handle two copies of the source
  tree.  We will in fact use a variation of this algorithm. Yes this is a brutish solution.

  The current pcp algorithm first 'gathers' the sources into tar files held in a temporary
  directory.  Then in a second 'copy to target' step, it expands the tar files into the
  target.  This is similar to piping through tar, which also required two tar calls. The
  two steps may be separated and done at different times. Hence, the staging area may
  be used for backing up a project.

Issue of renaming sources

   I would like to say that the target must be a directory, and that sources are never
   renamed. However, this approach would prevent us from doing some simple operations.
   For example, we would not be able to perform operations that remain within a given
   working directory.  Take for example we have a filesystem object named 'a', and we
   want a copy within our present working directory.  As the target must be a directory we
   would type:

      ex 0:
            > pcp a .

   This would gather 'a' into a temporary directory tar file, it would then expand that
   tar file into the present working directory. The expand step would find a with the same
   name that it wants to expand into, and find that the date is not older, and thus it
   would do nothing.  Furthermore if a were a subtree, it would traverse that subtree and
   find the same story for every single node in that subtree.

   Conventionally we would do such a copy as: 
      ex 1:
            > pcp a z
            > diff -r a z
              no differences found

    Where we intend to rename the copy to 'z'.  This gives us a new mode of operation, where
    the source has a different child_name than the target.  But we only have one target.  What if
    the user types:

      ex 2:
            > pcp a b c z
            > diff -r a z/a
              no differences found
            > diff -r b z/b
              no differences found
            > diff -r c z/c
              no differences found

    In this case we understand the user to be telling us to create a new directory, and to
    place copies of the source files in that directory.  In this case we use the source
    child_name as the name for the copy.  We use the child name of the target to name the
    new directory.  The target did not exist before, so we say that it was an imagined place
    to put the new directory.

    Then we would have three modes of copying:

         1. There are one or more sources and the target is an existing directory.  We just
         expand our gathered tar files into the target directory.

         2. There are multiple sources, the target is imagined.  We then create the target
         as a directory, and continue as per mode 1. Thus ex 2 above works as envisioned.

         3. There is a single source and the target is imagined.

           The temptation is to create exceptional behavior for this case, and to support
           the concept that the child_name of the target is to become the child_name for
           the copy.  The parent_path for the target would then be the directory that we
           expand into.  Thus, pcp would then behave like cp for this common case.

           But this would be our only example of a copy getting a different name than the source.
           Rather than having a non-orthoganal feature, I'm going to instead suggest that
           we support source to target renaming in general.

     Accordingly,

        ex 3:         
            > pcp '/home/matilda/a|z' .
            > diff -r a z
              no differences found

     So the vertical bar is a sort of piping notation, that says that the copy of '/home/matilda/a' is
     to be copied into the present working directory while being given the childname 'z'.  Of course
     I'm not going to implement this feature on the first version ;-)

     Here ex 4, performs the same thing as apparently intended in example 1.

        ex 4:
            > pcp 'a|z' .
            > diff -r a z
              no differences found

     In this case many of two of the sources take on new names, but one does not:

            > pcp 'a|q' 'b' 'c|s' z
            > diff -r a z/q
              no differences found
            > diff -r b z/b
              no differences found
            > diff -r c z/s
              no differences found

     .. actually, as just about any character can be in a file name, except perhaps for null and
     slash, such a method for renaming source operands would alias against possible filenames.

Issue of links and realname

  I would like to filter the source arguments down to their real names so that I could
  identify duplicates in the copy.  However, the child_names of the given sources matter
  in both gathering and copying to the target.


Issue of "." child_name

   os.path.split will return "." as the child name if the path was specified as ".". 

   Suppose the wryly user provides the path is "../../.".  This splits to:
        parent_path = "../../"
        child_name = "."

   When the user makes . the directory name, then the contents of the source directory
   should expand out as the contents of the target directory. This is not really a
   special case as tar will accept . as source.


Algorithm

  Setup, gather sources into a tar file, expand the tar file at the target.

  
pcp options

  These options are not yet implemented!  Currently there is only the default behavior,
  which is the same as not including any of these options.

  seems we need commands pgather  and p2target that set options to make easier to
  do this incrementally.  Perhaps pgatheras p2targetas that take argument
  pairs for renaming.

  .. options to provide the tar gather and the tar expand options?


  -d
  --dir        

                  Specifies the gather directory. When not specified, pcp will
                  gather the source files into a temporary directory of its choosing.

  -i              
  --incremental

                 The default behavior is to delete the whole of the gather directory after
                 the copy to target step has succeeded.  With this option, each tar file
                 is individually deleted after it has been successfuly expanded into the
                 target.

  -k <value>
  -keep <value>

               .. might be better to give access to tar options for both the gather
               and the expansion and let the user override the defaults if they want to.

                Sets the clobber behavior.

                    always          if a file exists, don't overwrite it
                    always-source   when gathering, "
                    always-target   when copying to target, "

                    never          never keep existing files if another file is proposed
                    never-source   when gathering, "
                    never-target   when copying to target, "

                    newer           keep the newest file
                    newer-source    when gathering files, "
                    newer-target    when copying to target, "

                 With 'always' clobbering files that come later in the src argument list
                 will clobber those that are already gathered or copied to the target.

                 'always' is taken as the value if no value is given.
                 'never' is the default if the option is not specified

                 This option may appear more than once.  Later values clobber earlier ones ;-)

  -n             
  --no-delete   

                 The tar files in the gather directory are not deleted after being expanded
                 out at the target.  This option will override the --incremental option.
                 This options makes it possible to create multiple copies by running pcp
                 repeatedly with the --target-only option.
  -l
  --last

                  Options come before arguments.  This may only occur as the last option.
                  This is useful if an argument happens to start with a dash. It is a
                  good practice to include it in scripts.

  -s
  --source-only  

                  All command arguments are interpreted as sources. The sources are
                  gathered, but are not copied to the target. --source-only commands may
                  be run multiple times before running a default pcp command or a
                  --disperse-only command.  The command prints the name of the temporary
                  directory used.

  -t
  --target-only 

                  Requires that --dir also be specified. There may only be one argument.
                  The tar files in the gather directory are expanded out at the target.
                  
  -x <pattern>
  --exclude <pattner>

                  files to exclude from the copy


  -z
  --compress

                  Make compressed tar files.

  
  






